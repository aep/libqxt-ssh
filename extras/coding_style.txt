LibQxt Coding Style Guidelines

1. Files
   1.1. Every header and source file begins with a header comment
   1.2. Comments must be written in C++-format (// ...). Multiline comments may be written in syntax of C (/* ... */).
   1.3. Header files
        1.3.1. The file name extension of a header file is .h
        1.3.2. A single public header file contains one public interface (class or namespace).
        1.3.3. Header files contain only declarations. Implementation belongs to source files.
               - Exception: inline and template functions must be placed within header files because of compiler limitations.
        1.3.4. Header files include only necessary header files.
               - Unnecessary include directives produce unnecessary dependencies between compile units.
        1.3.5. Use forward declarations whenever possible.
               - A forward declaration is enough when a type is referred only as reference or pointer.
        1.3.6. Header files do not contain using-clauses.
               - Using explicit namespace prefixes in header files lowers the risk of name conflicts.
        1.3.7. Header files must be protected against multiple inclusion
               - Multiple inclusion of header files causes a compile error.
                 #ifndef CLASSNAME_H
                 #define CLASSNAME_H
                     ...
                 #endif // CLASSNAME_H
        1.3.8. Include directives do not contain references to certain directories.
               - Using directory hierachies in include directives binds files strictly to certain environment and complicates portability.
                 #include "../../module/header.h" // WRONG
   1.4. Source files
        1.4.1. The file name extension of a source file is .cpp
        1.4.2. Source files include only necessary header files.
               - Unnecessary include directives produce unnecessary dependencies between compile units.
        1.4.3. Source files include first local headers, and then external library headers.
               - This order assures that header files do not depend on external library headers and leads to easier portability.
        1.4.4. Implementation of an interface is in the same order than in the header file.
               - This makes it easier to find the corresponding implementation.

2. Names
   2.1. Comments and symbolic names are in English.
   2.2. Symbolic names must not start with an underscore or contain two consecutive underscores.
        - ISO C++-standard reserves such names for compilers.
   2.3. Names of classes, structs, namespaces and typedefs start with an uppercase letter.
          class Name;
   2.4. Names of variables, functions and member functions start with a lowercase letter.
        - Exception: constructors and destructors must be named after corresponding class
          Type variable;
          void doSomething();
   2.5. Constants are written in uppercase.
          static const unsigned int BUFFER_LIMIT = 1024;

3. Variables and constants
   3.1. Variables should be declared within innermost possible scope.
        - Variables declared close to where they are used improves code clarity.
   3.2. Declare variables by separate clauses.
          char* p1, p2; // WRONG (p1 is a pointer, p2 is a char)
   3.3. Variables must be always initialized.
   3.4. Member variables are initialized in initialization list in order of declaration.
        - The initialization list is the only efficient way to initialize member variables.
   3.5. #define directive must not be used for defining constants or functional macros.
        - In C++, named constants are implemented as const variables and functional macros are replaced with inline functions.
   3.6. Constants are defined concentratedly in header files or at the beginning of source files.
   3.7. Truth values are expressed as boolean values; true or false.
        - C uses zero and non-zero as truth values. These work in C++ as well, but are not recommended by ISO C++-standard.

4. Layout and style
   4.1. Every programmer has his/her own programming style. The exact style does not matter as long as it is consistent per file.
        - This is important while applying changes to files which were originally written by somebody else.
        - Code looks awful and is unreadable if the programming style varies within a file.
   4.2. It is troublesome to handle files of more than thousand (1000) lines.
   4.3. It is not recommended to write functions of more than hundred (100) lines.
   4.4. Pointer and reference characters are recommended to place to type name.
        - Pointers and references are considered as types. In addition, this leads to better readability:
          Result* result = 0;
          void printResult(const Result& result);
   4.5. Indentation is done with spaces.
        - Tabulator characters are not recommended because different editors and viewers show them differently, often even unreadable.
   4.6. An indented code block follows every if,else,while,for and do primitive.
   4.7. Initial ({) and terminal (}) characters of code blocks must be clearly placed separately from code. The preferred way is to place them on separate lines.
   4.8. Every switch clause contains a default branch.

5. Mixing C and C++
   5.1. Do not use exit() or abort().
        - These functions stop execution without desctructing objects properly.
   5.2. The return value of main() is int.
        - Defined in ISO C++-standard.
   5.3. Do not use goto.
        - There are better control structures. Using goto leads to unreadable spaghetti code.
   5.4. Use output streams instead of C IO functions.
        - printf() has to type checks.
   5.5. Do not use malloc(), realloc() or free(). Use new and delete operators instead.
        - Old memory allocation routines know nothing about constructors and destructors.
   5.6. Use extern "C" while including headers of C libraries.
          extern "C" {
          #include <curses.h>
          }

6. Type conversions
   6.1. Do not use C-style cast. Use static_cast, dynamic_cast, reinterpret_cast and qobject_cast.
        - New type cast operators make sanity checks.
   6.2. Avoid const_cast whenever possible.
        - Constant is an attribute bound at design time. There should be no need to remove constness.

7. Functions and member functions

8. Classes and objects

9. Scope
   9.1. Memory management
   9.2. Constructing and destructing objects
   9.3. Copying objects
   9.4. Assigning objects

10. Inheritance

11. Templates

12. Exceptions

References:
- http://www.cs.tut.fi/~oliot/kirja/tyyliopas/
- http://doc.trolltech.com/qq/qq13-apis.html

Suggestions:
[19:54:43] <aep> 13:54:43> i would prefer  "Layout and style" beeing more strict
[19:54:43] <aep> 13:55:04> "The exact style does not matter as long as it is consistent per file."  thats a bad idea
[19:54:43] <aep> 13:55:19> it should be consistent all over the entire prohect
[19:54:43] <aep> 13:55:34> i think the GNU style or whatever it is called, we are currently using is all right
[19:54:43] <aep> 13:55:37> with 4 spaces
[19:54:43] <aep> 13:56:20> actually just removing that sentence is all right

[19:54:43] <ahigerd> 17:59:25> Suggestion for coding style:
[19:54:43] <ahigerd> 17:59:42> Use an enum in a namespace for related integer constants instead of const int or #define
[19:54:43] <ahigerd> 17:59:46> This is the Qt style.
[19:54:43] <ahigerd> 17:59:55> Er, in a namespace or class.

